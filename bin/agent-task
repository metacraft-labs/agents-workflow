#!/usr/bin/env ruby
# frozen_string_literal: true

require 'tempfile'
require 'fileutils'
require 'time'
require 'optparse'
require_relative 'lib/vcs_repo'

EDITOR_HINT = <<~HINT
  # Please write your task prompt above.
  # Enter an empty prompt to abort the task creation process.
  # Feel free to leave this comment in the file. It will be ignored.
HINT

def find_default_editor
  return ENV['EDITOR'] if ENV['EDITOR']

  editors = %w[nano pico micro vim helix vi]
  editors.find { |e| system("command -v #{e} > /dev/null 2>&1") } || 'nano'
end

options = {}
OptionParser.new do |opts|
  opts.on('--push-to-remote=BOOL', 'Push branch to remote automatically') do |val|
    options[:push_to_remote] = val
  end
  opts.on('--prompt=STRING', 'Use STRING as the task prompt') do |val|
    options[:prompt] = val
  end
  opts.on('--prompt-file=FILE', 'Read the task prompt from FILE') do |val|
    options[:prompt_file] = val
  end
end.parse!(ARGV)

branch_name = ARGV.shift
abort("Usage: #{File.basename(__FILE__)} <branch-name>") if branch_name.nil? || branch_name.strip.empty?

abort('Error: --prompt and --prompt-file are mutually exclusive') if options[:prompt] && options[:prompt_file]

prompt_content = nil
if options[:prompt]
  prompt_content = options[:prompt].dup
elsif options[:prompt_file]
  begin
    prompt_content = File.read(options[:prompt_file])
  rescue StandardError => e
    abort("Error: Failed to read prompt file: #{e.message}")
  end
end

# Initialize repository and create branch first
begin
  repo = VCSRepo.new
rescue StandardError => e
  puts e.message
  exit 1
end

orig_branch = repo.current_branch

begin
  repo.start_branch(branch_name)
rescue StandardError => e
  puts e.message
  exit 1
end

# Obtain the task description
task_content = nil
if prompt_content.nil?
  tempfile = Tempfile.new(['task', '.txt'])
  tempfile.write("\n")
  tempfile.write(EDITOR_HINT)
  tempfile.close

  editor = find_default_editor
  unless system("#{editor} #{tempfile.path}")
    repo.checkout_branch(orig_branch) if orig_branch
    case repo.vcs_type
    when :git
      system('git', 'branch', '-D', branch_name,
             chdir: repo.root, out: File::NULL, err: File::NULL)
    when :fossil
      system('fossil', 'branch', 'close', branch_name,
             chdir: repo.root, out: File::NULL, err: File::NULL)
    end
    abort('Error: Failed to open the editor.')
  end
  task_content = File.read(tempfile.path)
  task_content.sub!("\n#{EDITOR_HINT}", '')
  task_content.sub!(EDITOR_HINT, '')
else
  task_content = prompt_content
end
# Normalize CRLF line endings from editors and prompts to avoid Fossil commit issues
task_content.gsub!("\r\n", "\n")
if task_content.strip.empty?
  repo.checkout_branch(orig_branch) if orig_branch
  case repo.vcs_type
  when :git
    system('git', 'branch', '-D', branch_name,
           chdir: repo.root, out: File::NULL, err: File::NULL)
  when :fossil
    system('fossil', 'branch', 'close', branch_name,
           chdir: repo.root, out: File::NULL, err: File::NULL)
  end
  abort('Aborted: empty task prompt.')
end

# Create the agents task file path
now = Time.now.utc
year = now.year
month = format('%02d', now.month)
day = format('%02d', now.day)
hour = format('%02d', now.hour)
min = format('%02d', now.min)
filename = "#{day}-#{hour}#{min}-#{branch_name}"
tasks_dir = File.join(repo.root, '.agents', 'tasks', year.to_s, month)
FileUtils.mkdir_p(tasks_dir)
task_file = File.join(tasks_dir, filename)
commit_msg = "start-agent-task: #{branch_name}"

# Write the task content without automatic CRLF conversion
File.binwrite(task_file, task_content)

# Add and commit the file
repo.commit_file(task_file, commit_msg)

# Ask to push to default remote
push = nil
if options.key?(:push_to_remote)
  val = options[:push_to_remote].to_s.downcase
  truthy = %w[1 true yes y].include?(val)
  falsy = %w[0 false no n].include?(val)
  abort("Error: Invalid value for --push-to-remote: '#{options[:push_to_remote]}'") unless truthy || falsy
  push = truthy
else
  print 'Push to default remote? [Y/n]: '
  input = $stdin.gets
  abort('Error: Non-interactive environment, use --push-to-remote option.') if input.nil?
  answer = input.strip
  answer = 'y' if answer.empty?
  push = answer.downcase.start_with?('y')
end
repo.push_current_branch(branch_name) if push

# Return to original branch
repo.checkout_branch(orig_branch) if orig_branch
